<?php

/**
 * Facilitates signing in using Google API
 * Also used for adding/editing a single meeting
 *
 * Inspired by https://www.youtube.com/watch?v=oxa581kKBNg
 */
class GoogleAuth
{
    # The Google client
    protected $client;
    # Hold the access token generated by google client
    public static $auth;

    # The GoogleAuth class instance (singleton)
    private static $instance;

    /** Private constructor because of the singleton pattern */
    private function __construct()
    {
        # Load config
        $file = file_get_contents("app/config.json");
        $config = json_decode($file);

        # Start up the login
        require_once 'app/google-api-php-client/src/Google/autoload.php';
        # Create google client
        $client = new Google_Client();

        # Set the client variable
        $this->client = $client;

        # Set the credentials in order to make the authentication work
        $this->client->setClientId($config->{'google_auth'}->{'client_id'});
        $this->client->setClientSecret($config->{'google_auth'}->{'client_secret'});
        $this->client->setDeveloperKey($config->{'google_auth'}->{'developer_key'});

        # This is the url the google will redirect after successful authentication
        $this->client->setRedirectUri(SITE_URL.$config->{'google_auth'}->{'redirect_uri'});

        # We want to access user's calendar and email
        $this->client->addScope("https://www.googleapis.com/auth/calendar");
        $this->client->addScope("https://www.googleapis.com/auth/userinfo.email");
        $this->client->setAccessType('offline');
    }

    /**
     * A method to check if access token has expired (however not fully implemented
     * as there is a missing piece focusing on refreshToken.
     * @return bool true if expired
     */
    public function checkIfExpired()
    {
        if($this->client->isAccessTokenExpired())
        {
            // Get a new token based on the refresh token acquired
            // during the first authentication
            #$google_token = json_decode($_SESSION['access_token']);
            #$this->client->refreshToken($google_token->refresh_token);

            // Save new token to SESSION
            #$_SESSION['access_token']= $client->getAccessToken();
            return true;
        }
        else
            return false;
    }

    /**
     * Creates an instance of this class (only once) and returns it
     * @return GoogleAuth
     */
    public static function getInstance()
    {
        # Create the instance if it hasn't been created yet
        if(!isset(GoogleAuth::$instance))
            GoogleAuth::$instance = new GoogleAuth();

        # Set auth access token
        # Access token is session is set when user successfully signs in
        # using Google and is returned back to the page (the method to catch the code
        # that is passed back is in index.php)
        GoogleAuth::$auth = HTTPSession::getInstance()->ACCESS_TOKEN;

        # If auth code is not empty, it means that user was successfully signed in
        # using Google sign in, therefore set the received access token for client
        # and authorise using HTTPSession
        if(!empty(GoogleAuth::$auth))
        {
            GoogleAuth::$instance->setToken();

            # TODO: First we need to check if session is still valid
            # This implementation needs to be finished in the future version,
            # since it gets more complex and takes too much time
            if(GoogleAuth::$instance->checkIfExpired())
            {
                echo "Google session expired";
                die();
            }

            # Login the user using provided email
            HTTPSession::getInstance()->LoginGoogle(GoogleAuth::$instance->getUserEmail());
        }

        # Return the new instance or already existing instance
        return GoogleAuth::$instance;
    }

    /**
     * A method to authenticate the client using the code passed back from Google
     * @param $code String the code passed back from Google
     */
    public function checkCode($code)
    {
        # Authenticate the google client
        $this->client->authenticate($code);
        # Get access token by retrieving it from the authenticated client and save it to the session
        HTTPSession::getInstance()->ACCESS_TOKEN = $this->client->getAccessToken();
        # Set the access token
        $this->setToken();
    }

    /**
     * Saves refresh token to database in order to retrieve it
     * when token expires
     * @return mixed
     */
    public function saveRefreshToken()
    {
        $google_token = json_decode(HTTPSession::getInstance()->ACCESS_TOKEN);
        return $google_token->refresh_token;
    }

    /**
     * A method to set client's access token
     * Each time a page is refreshed, we need to set the token retrieved from the session,
     * in order to make sure the user is still logged in using Google
     */
    private function setToken()
    {
        $this->client->setAccessToken(HTTPSession::getInstance()->ACCESS_TOKEN);
    }

    /**
     * A method to return the email associated with the google account
     * @return String the user email
     */
    public function getUserEmail()
    {
        # Get ID token from session
        $idToken = json_decode(HTTPSession::getInstance()->ACCESS_TOKEN)->{'id_token'};

        # Get user payload
        $payload = $this->client->verifyIdToken($idToken)->getAttributes()['payload'];

        # And email from it
        $email = $payload['email'];

        return $email;
    }

    /**
     * A method to check whether a user is logged in using Google
     * @return bool
     */
    public function isLoggedIn()
    {
        if(!empty(self::$auth)) {
            $idToken = json_decode(self::$auth)->{'id_token'};
            # If ID token is verified correctly, user is still logged in
            if ($this->client->verifyIdToken($idToken))
                return true;
            else
                return false;
        }
        else
            return false;
    }

    /**
     * A method to generate a link for the "Sign in using Google" button
     * @return string the link
     */
    public function getAuthLink()
    {
        return $this->client->createAuthUrl();
    }

    /**
     * A method to add a new event to the google calendar
     * @param string $project the name of the project
     * @param string $users the participants names
     * @param string $datetimeStart when should the meeting start
     * @param string $datetimeEnd when should the meeting end
     * @param array $attendees who attends the meeting
     * @param null $recurrence if it should be reoccurring (not implemented in Meetings controller in this version)
     * @param string $timeZone the timezone the meeting should be added
     * @return String eventID the ID of the event generated by google
     */
    public function addEventToCalendar($project, $users, $datetimeStart = "0000-00-00T00:00:00", $datetimeEnd = "0000-00-00T00:00:00", $attendees = array(array('email' => 'cieslaremil@gmail.com')), $recurrence = null, $timeZone = "Europe/London") {

        # If we want the event to reoccur
        # This functionality is not implemented in Meetings controller in this version,
        # however code is prepared here for future use
        if($recurrence)
            $recurrence = 'RRULE:FREQ=WEEKLY;COUNT='.$recurrence;
        else
            $recurrence = array();

        # Get the calendar service
        $service = new Google_Service_Calendar($this->client);

        # Create a new event object using provided paramaters
        $event = new Google_Service_Calendar_Event(array(
            'summary' => 'GU Project Meeting ('.$project.'): '.$users,
            'location' => '',
            'description' => '',
            'start' => array(
                'dateTime' => $datetimeStart,
                'timeZone' => $timeZone,
            ),
            'end' => array(
                'dateTime' => $datetimeEnd,
                'timeZone' => $timeZone,
            ),
            'recurrence' => array(
                $recurrence
            ),
            'attendees' => $attendees,
            'reminders' => array(
                'useDefault' => FALSE,
                'overrides' => array(
                    array('method' => 'email', 'minutes' => 24 * 60)
                ),
            ),
        ));

        # Add event, provide calendar ID, which is email and $event object
        $event = $service->events->insert($this->getUserEmail(), $event);

        # Return the event ID in order to be saved in the database (we can edit the event afterwards)
        return $event->id;
    }

    /**
     * A method to edit an existing event in the google calendar
     * @param string $eventId the id of the event to be edited
     * @param string $datetimeStart the starting datetime
     * @param string $datetimeEnd the ending datetime
     * @param null $recurrence whether it should reoccur
     * @param string $timeZone
     * @return mixed the updated event id
     */
    public function editEventInCalendar($eventId, $datetimeStart = "0000-00-00T00:00:00", $datetimeEnd = "0000-00-00T00:00:00", $recurrence = null, $timeZone = "Europe/London")
    {
        # If we want the event to reoccur
        if($recurrence)
            $recurrence = 'RRULE:FREQ=WEEKLY;COUNT='.$recurrence;
        else
            $recurrence = array();

        # Get the calendar service
        $service = new Google_Service_Calendar($this->client);

        # Get the existing event from the google calendar
        $event = $service->events->get($this->getUserEmail(), $eventId);

        # Set the starting datetime
        $eventDatetimeStart = new Google_Service_Calendar_EventDateTime();

        $eventDatetimeStart->setDateTime($datetimeStart);
        $eventDatetimeStart->setTimeZone($timeZone);

        $event->setStart($eventDatetimeStart);

        # Set the ending datetime
        $eventDatetimeEnd = new Google_Service_Calendar_EventDateTime();

        $eventDatetimeEnd->setDateTime($datetimeEnd);
        $eventDatetimeEnd->setTimeZone($timeZone);

        $event->setEnd($eventDatetimeEnd);

        # Set whether it should reoccur
        $event->setRecurrence(array($recurrence));

        # Update the event
        $updatedEvent = $service->events->update($this->getUserEmail(), $event->getId(), $event);

        # Return the updated ID
        return $updatedEvent->id;

    }
}

